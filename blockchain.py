import streamlit
streamlit.set_page_config(page_icon=None, page_title="Blockchain Notes", layout="wide")
from streamlit_lottie import st_lottie
import requests

def load_lottie(url):
    r = requests.get(url)
    if r.status_code != 200:
        return None
    return r.json()
anime = load_lottie("https://assets9.lottiefiles.com/packages/lf20_ikaawl5v.json")
left, mid, right = streamlit.columns(3)
streamlit.title("BlockChain Notes")
with mid:
    st_lottie(anime,height = 300,width = 300,)


streamlit.subheader("Week 1")
notes = "Before we begin with the Ethereum blockchain and solidity, you all need to know what Blockchains are and some of the central concepts they are based on. According to Wikipedia, https://en.wikipedia.org/wiki/Blockchain, Blockchain is a series of Blocks (like a linked list) connected via cryptography rather than the address pointer usually stored in a linked list. In layman's terms, Cryptography is a mathematical tool that can convert any length input into, for example, a fixed-length output, called the hash, in the form of a uniform distribution on the range of the output, such that it is difficult to find any other input which produced the same output (this can be made increasingly difficult by using an extensive range of possible outputs, think why?). Blocks in a Blockchain typically store the previous Block's hash along with information about Transactions etc., in the Block. Linking the blocks together with cryptography essentially makes tampering with the Blockchain difficult; for example, if in a Blockchain there are n blocks, and the attacker tries to modify Block i, then the hash of the entire Block i will change, due to which the hash stored in Block i+1 will change, due to which the hash of Block i+! will change, and so on... the attacker would have to modify every Block after the ith block! Now, if the entire Blockchain was stored on a single server, like in a Bank, if the attacker modified the Blockchain in the above way, the attack would be successful! So, this is where the Peer-to-Peer (P2P) nature of Blockchains comes into view. A copy of the entire Blockchain network is stored on EVERY blockchain node, which is a part of the network, and there are millions of such nodes; thus, you can understand that it will be tough to modify the state of the Blockchain for the attacker in a short period. Modifying the Blockchain needs consensus (more than half the nodes should agree to a state of the Blockchain for it to be accepted). Thus to do something like this, the attacker will have to control 50% of the total number of nodes to make changes in the Blockchain network. This essentially shows that the Blockchain is tamper-proof! Suppose none of these technical terms made sense to you (it didnt to me as well when I was starting). In that case, the following video is a pretty good introduction to what blockchains and cryptocurrency are. He has explained the overall concept and some technical details on how cryptographic primitives are deployed inside to make the system tamper-proof (as we say it). Watch the video first and then go through the writeup again and try to make sense of the steps involved."


streamlit.write(notes)

streamlit.write("---")
streamlit.video("https://youtu.be/bBC-nXj3Ng4")
streamlit.write("---")
streamlit.subheader("Week 2")
week2 = "Mining is the process by which new blocks are published (added) onto the blockchain. The nodes are in a constant race to get transactions, verify them, package them into a block and publish them on a Blockchain, as they are driven by incentives (usually mining a block results in some reward being given to the miner, in the form of new Cryptocurrency tokens or rewards for approving transactions).\n Now, it is a straightforward process to verify a transaction. You might recall that for a block to be added to the blockchain, a majority of the nodes must agree to the contents of the block (must verify it). Thus, if the mining process just involved verifying transactions before publishing them, several nodes can publish a block simultaneously or with a minimal difference in publishing time, which can lead to difficulty in achieving consensus by the nodes (read https://en.wikipedia.org/wiki/Fork_(blockchain) ). Also, a malicious node can spam the network with a fraudulent block, which can have a significant chance of being accepted. \n Thus, it is crucial to make this process of mining (publishing new blocks) slower and the process of verification of blocks faster so that Blocks aren't mined simultaneously and malicious blocks can be appropriately verified and aren't spammed. Essentially, we want a difficult and time-consuming problem to solve but easy to verify."
streamlit.write(week2)
streamlit.info("https://en.wikipedia.org/wiki/Fork_(blockchain)")

streamlit.write("---")
streamlit.subheader("Week 3")
week3 = "We'll now discuss how mining works currently (called the proof of work mechanism), in a simple way: \n Suppose you have a string/an image/anything else. You convert it into binary. You put the bytes together. You now have a long sequence of bits. \n Now assume that this sequence of bits represents a number. A very large number. But still a finite positive integer. \n Suppose you have a mathematical function f(x): Z->[1,100]. This function can take any integer as the input, but always produces the output as an integer between 1 and 100. It is given that this function produces a uniform distribution. \n So you give this function an integer as an input. What is the probability that the output will be 5?\n1/100 ?\n What is the probability that the output will be less than or equal to 5? 1/20 ? \n Let's call 5 our target. Now suppose you want to throw random numbers into the function as input, and you want the output to be less than or equal to our target (which is 5). What is the expected number of times you'll have to try? \n  20 ? \n Now suppose you decrease the target to 4. What is the expected number of times you'll have to try to find an integer x such that f(x)<=target? \n25 ? \nThus, now you have to try harder (do more work) to find such a number.\n Now suppose you increase the target to 10. What is the expected number of times you'll have to try to find an integer x such that f(x)<=target? \n 10 ? \nNow you have to do less work to find such a number. \n This is the essence of mining. You try to find such an input for a function which produces an output that is less than the target. The function used is a hash function, like the SHA-256 hash function. It produces 256 bits as the output (hence the name). If you represent the bytes as an integer, it would lie in the range [0, 2^256). The number is usually written in the hexadecimal format. So the hash value can range from0x0000000000000000000000000000000000000000000000000000000000000000 to \n 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF. But the hash function can take any sequence of bytes as input. \n Also, if you change even a single bit in the input, the generated output is very different from the earlier output. For example: \n SHA256("'iitk1'") = b4576713e62c31a60b14df3d1fb5f50f29427af23e6acde5183ff661a5b5027a \n SHA256("'iitk2'") = c1b5c76ac773146743cde3a6d82b4a023c76b60e198ee3748a64d713a77f3d9a \n SHA256("'iitk21'") = 5ad35839b939dc27a16af30c2b8a932aa64baaf37f3487f7a8cfe22d42ca81d7 \n\n Here, we had some constant data ("'iitk'"), and a changing value (the number at the end). Mining is the process of finding this changing value that when combined with our data ("'iitk'" in our case) will produce an output below the target. Since the range of SHA256 hash function is huge, the target chosen is very high. If we chose the target to be \n 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, the smallest positive integer that satisfies out target is 33307.\n SHA256("'iitk33307'") = bad48e129ee8e2e5339662f920a20509e8cb35118f044b5e260af38c1ae5a49aAs soon as we have found this magic number 33307, we have achieved success.\n You might think that this was pretty fast, but try reducing the target value, to say 0x000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF. You'll see that you will need significantly more time. However, verifying that the nonce you found is correct takes a split second, and you can see that you got the nonce correctly using this https://emn178.github.io/online-tools/sha256.html !"
streamlit.write(week3)